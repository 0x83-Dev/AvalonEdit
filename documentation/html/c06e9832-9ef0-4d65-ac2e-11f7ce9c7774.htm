<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><title>Text Rendering</title><link rel="stylesheet" type="text/css" href="../styles/presentation.css" /><script type="text/javascript" src="../scripts/script_prototype.js"> </script><script type="text/javascript" src="../scripts/EventUtilities.js"> </script><script type="text/javascript" src="../scripts/StyleUtilities.js"> </script><script type="text/javascript" src="../scripts/SplitScreen.js"> </script><script type="text/javascript" src="../scripts/ElementCollection.js"> </script><script type="text/javascript" src="../scripts/MemberFilter.js"> </script><script type="text/javascript" src="../scripts/CollapsibleSection.js"> </script><script type="text/javascript" src="../scripts/LanguageFilter.js"> </script><script type="text/javascript" src="../scripts/CookieDataStore.js"> </script></head><body><img id="copyImage" style="display:none; height:0; width:0;" src="../icons/copycode.gif" alt="Copy image" title="Copy image" /><img id="copyHoverImage" style="display:none; height:0; width:0;" src="../icons/copycodeHighlight.gif" alt="CopyHover image" title="CopyHover image" /><div id="control"><span class="productTitle">AvalonEdit</span><br /><span class="topicTitle">Text Rendering</span><br /><div id="toolbar"><span id="languageFilter"><select id="languageSelector" onchange="var names = this.value.split(' '); toggleVisibleLanguage(names[1]); switchLanguage(names, this.value);"><option value="CSharp cs">C#</option><option value="VisualBasic vb">Visual Basic</option><option value="ManagedCPlusPlus cpp">Visual C++</option></select></span></div></div><div id="main"><span style="color: DarkGray"></span><div class="summary"><p>This document describes how the TextView class renders the text, and
		how you can extend the text rendering process to add new features to the text editor.
		</p></div><div class="introduction"><p>The <span sdata="cer" target="T:ICSharpCode.AvalonEdit.Rendering.TextView"><a href="9d38e070-994f-f499-febe-de0cc49828b8.htm">ICSharpCode.AvalonEdit.Rendering<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>TextView</a></span>
      class is the heart of AvalonEdit.
      It takes care of getting the document onto the screen.</p><p>To do this in an extensible way, the TextView uses its own kind of model:
      the <span sdata="cer" target="T:ICSharpCode.AvalonEdit.Rendering.VisualLine"><a href="2945b06d-8cd4-bfeb-eabf-aa0fe2830356.htm">VisualLine</a></span>.
      Visual lines are created only for the visible part of the document.</p><p>
      The rendering process looks like this:
	  <div class="mediaCenter"><img src="../media/RenderingPipeline.png" /></div>
	  The "element generators", "line transformers" and "background renderers" are
	  the extension points; it is possible to add custom implementations of them to
	  the TextView to implement additional features in the editor.
      </p></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Lifetime of VisualLines</div><div class="sectionContent"><div class="subsection"><p>
			VisualLines are only created for the visible part of the document.
			Lots of actions can trigger their creation, but most commonly the creation will be
			caused by the MeasureOverride method of TextView.
			When the TextView is measured, it uses the height tree to determine the first
			document line in the visible region. Then, it constructs and measures a VisualLine
			for that first line, and repeats that with the following lines
			until the visible region is filled.
			</p><p>
			The TextView caches VisualLines - when the user scrolls down, only the VisualLines
			coming into view are created, the rest is reused.
			The VisualLine cache can be manually invalidated using the Redraw method family;
			moreover, lots of actions cause automatic invalidation:
			<ul><li>any change in the document will invalidate the affected VisualLines</li><li>changing the width of the TextView invalidates all VisualLines if word-wrap is enabled</li><li>changing any text editor settings (word-wrap, font size, etc.) will invalidate all VisualLines</li><li>VisualLines leaving the visible area after scrolling will be disposed</li></ul>
			In general, manual invalidation is required only if you have written a text editor extension
			(BackgroundRenderer, VisualLineElementGenerator or VisualLineTransformer) that also consumes
			external data - in that case, you'll have to notify the text editor that VisualLines need
			to be recreated when your external data changes.
			</p><div class="alert"><table><tr><th><img src="../icons/alert_note.gif" title="Note" /> <b>Note:</b></th></tr><tr><td><p>If external data used by your text editor extension changes, call
				<span sdata="cer" target="M:ICSharpCode.AvalonEdit.Rendering.TextView.Redraw"><a href="7161e59f-a314-9b01-92b8-12874e8543b0.htm">TextView<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>Redraw<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span><span class="fs">()</span></span></a></span>
				to invalidate the VisualLine.
			  </p></td></tr></table></div><p>
			Invalidating VisualLines does not cause immediate recreation of the lines!
			Rather, the VisualLines are recreated when the text view is next re-measured.
			While measurement in WPF normally happens with DispatcherPriority.Render,
			the TextView also supports redrawing with a lower priority than that.
			For example, normal text insertion causes a redraw at background priority, so that
			in case the user types faster than the text view can redraw, there will be only
			one redraw for multiple input actions.
			</p><div class="alert"><table><tr><th><img src="../icons/alert_note.gif" title="Note" /> <b>Note:</b></th></tr><tr><td><p>
			  	The TextView will never return invalid lines to you, but you
			  	may run into the case that the valid visual lines are not available.
			  </p><p>
			    What happens in this case depends on the method you are calling -
			    the new visual line might get created automatically,
			    null could be returned, or you may get a
				<span sdata="cer" target="T:ICSharpCode.AvalonEdit.Rendering.VisualLinesInvalidException"><a href="beb21736-2f0d-67e7-76bd-470b361a8325.htm">VisualLinesInvalidException</a></span>.
			  </p><p>
				You can call
				<span sdata="cer" target="M:ICSharpCode.AvalonEdit.Rendering.TextView.EnsureVisualLines"><a href="fdef58ab-f3f7-f1c3-bbc6-b04325a81b22.htm">TextView<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>EnsureVisualLines<span class="languageSpecificText"><span class="cs">()</span><span class="cpp">()</span><span class="nu">()</span><span class="fs">()</span></span></a></span>
				to make the text view create all VisualLines in the visible region.
			  </p></td></tr></table></div></div></div></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Building visual line elements</div><div class="sectionContent"><div class="subsection"><p>
			As a first step, the VisualLineElementGenerators are used to produce elements. The
			room in between the elements returned from the generators is filled with text elements.
			Then, the VisualLine assigns the VisualColumn and RelativeTextOffset properties of the line elements.
			</p><p>
			For example, a line contains the text "Hello, World". 
			The user has enabled "ShowSpaces", so the text editor should show a little dot instead of the space.
			In this case, the SingleCharacterElementGenerator, which is responsible for ShowSpaces, will produce
			a "SpaceTextElement" for the space character. Because no other generators are interested in the line,
			the remaining strings "Hello," and "World" will be represented by VisualLineText elements.
			</p></div></div></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Transforming visual line elements</div><div class="sectionContent"><div class="subsection"><p>
			After that, the IVisualLineTransformers are used to modify the produced line elements. Transformers
			must not add elements, but they may split existing elements, e.g. to colorize only parts of an
			element. When splitting elements (or somehow modifying the elements collection), care must be taken
			that the VisualColumn,VisualLine,RelativeTextOffset and DocumentLength properties stay correct.
			</p><p>
			The ColorizingTransformer base class provides helper methods for splitting, so the derived class
			can simply say "color this section in that color".
			</p><p>
			The DocumentColorizingTransformer extends the ColorizingTransformer and additionally
			allows highlighting on per DocumentLine, coloring text segments (instead of directly
			working with visual line elements).
			</p></div></div></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Constructing TextLines</div><div class="sectionContent"><div class="subsection"><p>
			After building the visual line elements, the TextLines for the visual line are constructed.
			A visual line may result in multiple text lines when word wrapping is active or when special visual
			line elements force a line break.
			Building text lines:
			The text line construction is done by a WPF TextFormatter.
			The VisualLineTextSource will take the visual line elements and build WPF TextRuns from it,
			while the WPF TextFormatter takes care of word wrapping etc.
			VisualLineElements are requested to produce TextRuns for their full or a partial length.
			The TextView will take care to measure any inline UI elements in the visual lines.
			</p></div></div></div><div class="section"><div class="sectionTitle" onclick="toggleSection(this.parentNode)"><img src="../icons/collapse_all.gif" /> Rest of the Rendering</div><div class="sectionContent"><div class="subsection"><p>
			After the visible region is filled, the TextView updates the heights stored in the document lines to
			the measured heights. This way, scrolling takes account for word-wrapping.
			The constructed text lines are stored for the arrange and render steps.
			Now, finally, the measure step is complete.
			</p><p>
			The WPF arrange step doesn't have much work to do:
			It just arranges inline UI elements at their position inside the text.
			</p><p>
			The actual rendering does not happen directly in the TextView, but in its
			various layers.
			</p><p>
			These are the predefined layers:
			<ul><li>Background layer: renders the background colors associated with the visual elements</li><li>Selection layer: renders the background of the selection</li><li>Text layer: renders the TextLines that were constructed during the Measure step.
			    Starting with AvalonEdit 4.1, the TextLayer uses child elements to draw the text: one DrawingVisual for each VisualLine.
			   </li><li>
			    Immediately after the text layer, any inline UI elements are placed as if they were separate layers.
			   </li><li>Caret layer: renders a blinking caret</li></ul>
			It's also possible to insert new layers into the TextView using the
			<span sdata="cer" target="M:ICSharpCode.AvalonEdit.Rendering.TextView.InsertLayer(System.Windows.UIElement,ICSharpCode.AvalonEdit.Rendering.KnownLayer,ICSharpCode.AvalonEdit.Rendering.LayerInsertionPosition)"><a href="85b476fe-e4c0-ca21-2f08-133c4c779ac9.htm">TextView<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>InsertLayer(UIElement, KnownLayer, LayerInsertionPosition)</a></span>
			method.
			This allows adding custom interactive components to the editor
			while being in full control of the Z-Order.
			</p></div></div></div><div id="seeAlsoSection" class="section"><div class="sectionTitle">See Also</div><div class="sectionContent"><span sdata="cer" target="T:ICSharpCode.AvalonEdit.Rendering.TextView"><a href="9d38e070-994f-f499-febe-de0cc49828b8.htm">TextView</a></span><br /></div></div><div id="footer"><p />Copyright 2008-2014, Daniel Grunwald</div></div></body></html>